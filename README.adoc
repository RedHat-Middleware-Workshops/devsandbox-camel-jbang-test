= Camel JBang - First steps

_Camel JBang_ is a command-line interface (CLI) that helps you run, iterate, and test your _Apache Camel_ applications without complex setups. It accelerates prototyping: create, validate, and tweak flows quicklyâ€”ideal for rapid experimentation and for getting a feel of what _Camel_ can do.

image::docs/labs/intro-cjbang/images/camel-jbang.png[width=40%]

This guide gives you a short, hands-on introduction. You'll use a small game to discover a few core commands and see how much you can do with _Camel JBang_ from the terminal.

== Camel JBang at play

=== Find your terminal

Whether you're working on your local machine or in Dev Spaces, you'll need to open a terminal. If you're working locally, we recommend VS Code (the examples below are based on this editor), but you can use any terminal you prefer.

Open a terminal, create a `lab` directory, and change into it:

[source,bash]
----
mkdir lab
cd lab
----

The first time, your `lab` directory is empty:

.Example:
----
ğŸ“ workshop
   ğŸ“ lab    (empty)
----

The picture below shows the terminal in VS Code.

image::docs/labs/intro-cjbang/images/crw-terminal.png[align="left", width=100%]

The instructions that follow will ask you to run commands. Run them from your terminal.

=== Playing a game with Camel JBang

Playing is a great way to learn. Here we'll use a small game to discover a few things _Camel JBang_ can do.

NOTE: Later we'll go deeper into the core of the workshop.

Pretend we're organizing a tennis tournament. First, *player1*:

Copy and paste the following into your terminal to create the `player1.yaml` file:

NOTE: If your terminal asks to confirm the paste, you can tick "âœ“ Do not ask me again" and click *Paste*.

image::docs/labs/intro-cjbang/images/paste-multiline.jpg[width=30%]

[source,bash]
----
cat <<EOF > player1.yaml
- route:
    id: player1
    from:
      uri: file:court/side1
      parameters:
        delete: true
      steps:
        - log:
            message: (ping)â‹…â‹…â‹…â”â”â”â–º ğŸ¥
        - delay:
            constant: "{{pace:3000}}"
        - to:
            uri: file:court/side2
EOF
----

*Note:* player1 is on one side of the court and hits every ball. When hitting, the ball crosses the court (at a given pace) to the other side.

Run this to get player1 on the court:

[source,bash]
----
camel run player1.yaml
----

*Note:* There are no dependency descriptors or extra filesâ€”_Camel JBang_ reads `player1.yaml` and runs the route.

In your terminal you'll see player1 ready. Example output:

.Example output
----
2025-10-26 12:40:32.210 INFO 2243 --- [           main] e.camel.impl.engine.AbstractCamelContext : Apache Camel 4.15.0 (player1) started in 242ms ...
----

In your folder you'll see where player1 is waiting for balls. Example:

----
â¯ lab â¯ court/side1
----

=== Throw a ball

Player1 is ready. Give them a ğŸ¥.

From the terminal's top-right corner, click *+* to open a second terminal:

image::docs/labs/intro-cjbang/images/terminal-plus.jpg[width=30%]

In the new terminal, use _Camel JBang_ to send a ball to player1:

TIP: The `send` command is useful for testing: you can send balls to routes and see what happens.

[source,bash]
----
camel cmd send player1 --header CamelFileName=ğŸ¥
----

Switch back to the first terminal where player1 is running:

image::docs/labs/intro-cjbang/images/terminal-one.jpg[width=25%]

You should see player1 hitting the ball to the other side. Example output:

----
2025-10-26 12:50:12.951 INFO 2243 --- [e://court/side1] player1.yaml:8 : (ping)â‹…â‹…â‹…â”â”â”â–º ğŸ¥
----

Check the court: the ball should be on the other side:

image::docs/labs/intro-cjbang/images/court-side2-ball.jpg[width=8%]

*Note:* With only one player, the ball ends up on the other side and stays there.

Before continuing, stop player1 with *Ctrl+C*.

=== The ball boy

Next we add the ball boy to keep the court tidy.

Copy and paste this into your terminal to create `the-ballboy.yaml`:

[source,bash]
----
cat <<EOF > the-ballboy.yaml
- route:
    id: ballboy
    from:
      uri: timer:check-court
      steps:
        - filter:
            groovy:
              expression: >-
                def court = ['court/side1/ğŸ¥', 'court/side2/ğŸ¥'];
                def file = court.find { new File(it).exists() }?.with { new File(it) };

                if (file?.exists() && (System.currentTimeMillis() - file.lastModified()) > {{wait:6000}} )
                  return file.delete();
                else
                  return false;
            steps:
              - log:
                  message: "ğŸ¥ cleared, court ready."
EOF
----

*Note:* In _Camel_, some tasks need a bit of logic. The ball boy uses _Groovy_ to check both sides of the court and remove any ball that has been sitting for too long (6 seconds).

When you're ready, start everything with:

[source,bash]
----
camel run *
----

*Note:* _Camel JBang_ supports a `*` wildcard when you have multiple route files. It also picks up property files. Optional example file `game.properties` (for reference only; you don't run this in the terminal):

[source,properties]
----
# Ball pace (millis) when players hit. Lower value is faster.
pace=3000

# Ballboy waits (millis) before picking up the ball.
wait=6000
----

In the logs you should see the ball boy at work. Example output:

----
2025-10-26 18:23:53.558 INFO 20299 --- [r://check-court] the-ballboy.yaml:17 : ğŸ¥ cleared, court ready.
----

On the court, the ball will have been cleared:

image::docs/labs/intro-cjbang/images/court-clear.jpg[width=8%]

Let player1 practice a bit more, then press *Ctrl+C* to stop.

=== Set up the tournament

Practice is over; time for a real game.

You need a second player. Here is *player2*:

Copy and paste to create `player2.yaml`:

[source,bash]
----
cat <<EOF > player2.yaml
- route:
    id: player2
    from:
      uri: file:court/side2
      parameters:
        delete: true
      steps:
        - log:
            message: "      ğŸ¥ â—„â”â”â”â‹…â‹…â‹…(pong)"
        - delay:
            constant: "{{pace:3000}}"
        - to:
            uri: file:court/side1
EOF
----

*Note:* Each player does one job: receive from one side and send to the other.

To run a proper "tournament":

. Stop any running routes. Press *Ctrl+C* if something is still running.
. Start the ball boy first (in the background):
+
[source,bash]
----
camel run the-ballboy.yaml --background
----
+
The `--background` flag runs the process detached.
. Start both players (in the background, with live reload):
+
[source,bash]
----
camel run player1.yaml --background --dev
----
+
[source,bash]
----
camel run player2.yaml --background --dev
----
+
The `--dev` flag enables live code reload (e.g. when you change the route).
. Check that everyone is running:
+
[source,bash]
----
camel ps
----
+
*Note:* `ps` shows which routes are running and their status.
. Watch the logs:
+
[source,bash]
----
camel log
----
+
*Note:* `log` aggregates output from all running routes. You can also follow a single route, e.g. `camel log player1`.

The ball boy and both players should be ready.

=== Let the game begin

Player1 serves. Send a ball:

[source,bash]
----
camel cmd send player1 --header CamelFileName=ğŸ¥
----

In the terminal you should see both players hitting the ball. Example output:

----
player1    | 2025-10-26 19:01:36.006 INFO 22363 --- [e://court/side1] player1.yaml:8 : (ping)â‹…â‹…â‹…â”â”â”â–º ğŸ¥
player2    | 2025-10-26 19:01:39.106 INFO 22578 --- [e://court/side2] player2.yaml:8 :       ğŸ¥ â—„â”â”â”â‹…â‹…â‹…(pong)
player1    | 2025-10-26 19:01:42.509 INFO 22363 --- [e://court/side1] player1.yaml:8 : (ping)â‹…â‹…â‹…â”â”â”â–º ğŸ¥
player2    | 2025-10-26 19:01:45.610 INFO 22578 --- [e://court/side2] player2.yaml:8 :       ğŸ¥ â—„â”â”â”â‹…â‹…â‹…(pong)
...
----

That's a rally.

You can also see the ball file moving on disk (court/side1 and court/side2):

image::docs/labs/intro-cjbang/images/court-rally.jpg[width=18%]

Player1 stops to tie their laces. Stop their route:

[source,bash]
----
camel cmd stop-route --id player1
----

You'll see player2 hit once more, player1 stop, and the ball boy clear the ball. Example output:

----
player2    | ... :       ğŸ¥ â—„â”â”â”â‹…â‹…â‹…(pong)
player1    | ... : Stopped player1 (file://court/side1)
the-ballboy| ... : ğŸ¥ cleared, court ready.
----

==== Game statistics

Inspect route stats:

[source,bash]
----
camel get route
----

.Example output
----
  PID   NAME         ID       FROM                            REMOTE  STATUS    AGE   COVER  MSG/S  TOTAL  FAIL  INFLIGHT  MEAN  MIN   MAX   LAST  DELTA  SINCE-LAST
 22140  the-ballboy  ballboy  timer://check-court                     Started   6m3s    2/2   1.00    363     0         0     2     0   841     0      0            0s/0s/-
 22363  player1      player1  file://court/side1?delete=true    x     Stopped           3/3   0.00     25     2         0  2001  2001  2007  2001      0  1m31s/1m29s/1m41s
 22578  player2      player2  file://court/side2?delete=true    x     Started  5m21s    3/3   0.00     23     0         0  2001  2001  2012  2001      0      1m29s/1m27s/-
----

*Note:* player1 is stopped but still listed; the ball boy and player2 keep running.

==== The game resumes

Player1 is ready again. Start the route:

[source,bash]
----
camel cmd start-route --id player1
----

Player2 serves. Send a ball:

[source,bash]
----
camel cmd send player2 --header CamelFileName=ğŸ¥
----

The rally continues.

==== Game conditions

Suppose the weather changes: wind, clouds, a bit of rain. We can change the "game conditions" in the YAML.

While the rally is going, edit the files:

* In *`player1.yaml`*: change the log message to `p1ng` and the delay to `{{pace:4000}}` (slower).
* In *`player2.yaml`*: change the log message to `p0ng` and the delay to `{{pace:4000}}` (slower).

*Note:* With `--dev`, _Camel JBang_ reloads the routes and the new behavior takes effect without restarting.

In the logs you'll see reload messages. Example output:

----
player1    | ... RouteWatcherReloadStrategy : Routes reloaded summary (total:1 started:1)
player1    | ... RouteWatcherReloadStrategy : Started player1 (file://court/side1) (source: player1.yaml:4)
----

Then the slower "p1ng" / "p0ng" messages. Example output:

----
player2    | ... :       ğŸ¥ â—„â”â”â”â‹…â‹…â‹…(p0ng)
player1    | ... : (p1ng)â‹…â‹…â‹…â”â”â”â–º ğŸ¥
...
----

=== Abrupt end

Player1 slips on the wet court and has to leave the game. Stop that route:

[source,bash]
----
camel stop player1
----

TIP: Run `camel ps` to confirm player1 is no longer in the list.

Then stop everything:

[source,bash]
----
camel stop
----

*Note:* With no name, _Camel JBang_ stops all running Camel processes.

That's the end of this matchâ€”but you can run the game again anytime.

ğŸ¥ğŸ¥ğŸ¥
Keep exploring the workshop for more.
ğŸ¥ğŸ¥ğŸ¥

'''

== Clean up your lab folder

Keep your `lab` folder clean for the next exercises.

Run:

[source,bash]
----
rm -r *
----

Your `lab` folder should contain no files or directories.

'''

== Closing words

This was a short introduction to working quickly with a few _Camel_ route files. _Camel JBang_ has many more commands to help with development.

Quick recap of what you used:

*Running Camel*

* Run a single file: `camel run <file>.yaml`
* Run all: `camel run *`
* Run in the background: `camel run <file>.yaml --background`
* Run with live reload: `camel run <file>.yaml --background --dev`

*Troubleshooting and monitoring*

* List running instances: `camel ps`
* Follow logs: `camel log` or `camel log <route-id>`
* Start/stop routes: `camel cmd start-route --id <id>`, `camel cmd stop-route --id <id>`
* Route details: `camel get route`
* Send a message: `camel cmd send <route-id> --header CamelFileName=ğŸ¥`

*Stopping Camel*

* Stop one instance: `camel stop <name>`
* Stop all: `camel stop`

Continue with other chapters in the workshop to see what _Camel JBang_ can do beyond this intro, and how it fits with other tools for working quickly with _Apache Camel_â€”from initial concepts to deployment on platforms like OpenShift.
